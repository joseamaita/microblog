# Basic Development with Flask and Microblog

## Pagination

### Introduction

In the previous section, I have made several database changes necessary 
to support the "follower" paradigm that is so popular with social 
networks. With that functionality in place, I'm ready to remove the last 
piece of scaffolding that I have put in place in the beginning, the fake 
posts. In this section, the application will start accepting blog posts 
from users, and also deliver them in the home and profile pages.

### Submission of Blog Posts

Let's start with something simple. The home page needs to have a form in 
which users can type new posts. First I create a form class:

```python
# app/forms.py: Blog submission form
class PostForm(FlaskForm):
    post = TextAreaField('Say something', validators=[
        DataRequired(), Length(min=1, max=140)])
    submit = SubmitField('Submit')
```

Next, I can add this form to the template for the main page of the 
application:

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ current_user.username }}!</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.post.label }}<br>
            {{ form.post(cols=32, rows=4) }}<br>
            {% for error in form.post.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
    {% for post in posts %}
    <p>{{ post.author.username }} says: <b>{{ post.body }}</b></p>
    {% endfor %}
{% endblock %}
```

The changes in this template are similar to how previous forms were 
handled. The final part is to add the form creation and handling in the 
view function:

```python
# app/routes.py: Post submission form in index view function
from app.forms import PostForm
from app.models import Post

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    form = PostForm()
    if form.validate_on_submit():
        post = Post(body=form.post.data, author=current_user)
        db.session.add(post)
        db.session.commit()
        flash('Your post is now live!')
        return redirect(url_for('index'))
    posts = [
        {
            'author': {'username': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'username': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
    return render_template('index.html', 
                           title = 'Home', 
                           posts = posts, 
                           form = form)
```

Let's review the changes in this view function one by one:

* I'm now importing the `Post` and `PostForm` classes.
* I accept `POST` requests in both routes associated with the `index` 
view function in addition to `GET` requests, since this view function 
will now receive form data.
* The form processing logic inserts a new `Post` record into the 
database.
* The template receives the `form` object as an additional argument, so 
that it can render the text field.

Before I continue, I wanted to mention something important related to 
processing of web forms. Notice how after I process the form data, I end 
the request by issuing a redirect to the home page. I could have easily 
skipped the redirect and allowed the function to continue down into the 
template rendering part, since this is already the index view function.

So, why the redirect? It is a standard practice to respond to a `POST` 
request generated by a web form submission with a redirect. This helps 
mitigate an annoyance with how the refresh command is implemented in web 
browsers. All the web browser does when you hit the refresh key is to 
re-issue the last request. If a `POST` request with a form submission 
returns a regular response, then a refresh will re-submit the form. 
Because this is unexpected, the browser is going to ask the user to 
confirm the duplicate submission, but most users will not understand 
what the browser is asking them. But if a `POST` request is answered 
with a redirect, the browser is now instructed to send a `GET` request 
to grab the page indicated in the redirect, so now the last request is 
not a `POST` request anymore, and the refresh command works in a more 
predictable way.

This simple trick is called the [Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get) 
pattern. It avoids inserting duplicate posts when a user inadvertently 
refreshes the page after submitting a web form.

![img](08-pagination-a.png)

![img](08-pagination-b.png)

### Displaying Blog Posts

If you recall, I created a couple of fake blog posts that I've been 
displaying in the home page for a long time. These fake objects are 
created explicitly in the `index` view function as a simple Python list:

```python
    posts = [
        {
            'author': {'username': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'username': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
```

But now I have the `followed_posts()` method in the `User` model that 
returns a query for the posts that a given user wants to see. So now I 
can replace the fake posts with real posts:

```python
# app/routes.py: Display real posts in home page
@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    # ...
    posts = current_user.followed_posts().all()
    return render_template('index.html', 
                           title = 'Home', 
                           posts = posts, 
                           form = form)
```

The `followed_posts` method of the `User` class returns a SQLAlchemy 
query object that is configured to grab the posts the user is interested 
in from the database. Calling `all()` on this query triggers its 
execution, with the return value being a list with all the results. So I 
end up with a structure that is very much alike the one with fake posts 
that I have been using until now. It's so close that the template does 
not even need to change.

![img](08-pagination-c.png)

### Making It Easier to Find Users to Follow

As I'm sure you noticed, the application as it is does not do a great 
job at letting users find other users to follow. In fact, there is 
actually no way to see what other users are there at all. I'm going to 
address that with a few simple changes.

I'm going to create a new page that I'm going to call the "Explore" 
page. This page will work like the home page, but instead of only 
showing posts from followed users, it will show a global post stream 
from all users. Here is the new explore view function:

```python
# app/routes.py: Explore view function
@app.route('/explore')
@login_required
def explore():
    posts = Post.query.order_by(Post.timestamp.desc()).all()
    return render_template('index.html', 
                           title = 'Explore', 
                           posts = posts)
```

Did you notice something odd in this view function? 
The `render_template()` call references the *index.html* template, which 
I'm using in the main page of the application. Since this page is going 
to be very similar to the main page, I decided to reuse the template. 
But one difference with the main page is that in the explore page I do 
not want to have a form to write blog posts, so in this view function I 
did not include the `form` argument in the template call.

To prevent the *index.html* template from crashing when it tries to 
render a web form that does not exist, I'm going to add a conditional 
that only renders the form if it is defined:

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ current_user.username }}!</h1>
    {% if form %}
    <form action="" method="post">
        ...
    </form>
    {% endif %}
    ...
{% endblock %}
```

I'm also going to add a link to this new page in the navigation bar:

```html
            <a href="{{ url_for('explore') }}">Explore</a>
```

Remember the *_post.html* sub-template that I have introduced previously 
to render blog posts in the user profile page? This was a small template 
that was included from the user profile page template, and was separate 
so that it can also be used from other templates. I'm now going to make 
a small improvement to it, which is to show the username of the blog 
post author as a link:

```html
    <table>
        <tr valign="top">
            <td><img src="{{ post.author.avatar(36) }}"></td>
            <td>
                <a href="{{ url_for('user', username=post.author.username) }}">
                    {{ post.author.username }}
                </a>
                says:<br>{{ post.body }}
            </td>
        </tr>
    </table>
```

I can now use this sub-template to render blog posts in the home and 
explore pages:

```html
    ...
    {% for post in posts %}
        {% include '_post.html' %}
    {% endfor %}
    ...
```

The sub-template expects a variable named `post` to exist, and that is 
how the loop variable in the index template is named, so that works 
perfectly.

With these small changes, the usability of the application has improved 
considerably. Now a user can visit the explore page to read blog posts 
from unknown users and based on those posts find new users to follow, 
which can be done by simply clicking on a username to access the profile 
page. Amazing, right?

At this point I suggest you to try the application once again, so that 
you experience these last user interface improvements.

![img](08-pagination-d.png)

![img](08-pagination-e.png)

![img](08-pagination-f.png)
