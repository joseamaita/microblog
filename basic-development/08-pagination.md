# Basic Development with Flask and Microblog

## Pagination

### Introduction

In the previous section, I have made several database changes necessary 
to support the "follower" paradigm that is so popular with social 
networks. With that functionality in place, I'm ready to remove the last 
piece of scaffolding that I have put in place in the beginning, the fake 
posts. In this section, the application will start accepting blog posts 
from users, and also deliver them in the home and profile pages.

### Submission of Blog Posts

Let's start with something simple. The home page needs to have a form in 
which users can type new posts. First I create a form class:

```python
# app/forms.py: Blog submission form
class PostForm(FlaskForm):
    post = TextAreaField('Say something', validators=[
        DataRequired(), Length(min=1, max=140)])
    submit = SubmitField('Submit')
```

Next, I can add this form to the template for the main page of the 
application:

```html
{% extends "base.html" %}

{% block content %}
    <h1>Hi, {{ current_user.username }}!</h1>
    <form action="" method="post">
        {{ form.hidden_tag() }}
        <p>
            {{ form.post.label }}<br>
            {{ form.post(cols=32, rows=4) }}<br>
            {% for error in form.post.errors %}
            <span style="color: red;">[{{ error }}]</span>
            {% endfor %}
        </p>
        <p>{{ form.submit() }}</p>
    </form>
    {% for post in posts %}
    <p>{{ post.author.username }} says: <b>{{ post.body }}</b></p>
    {% endfor %}
{% endblock %}
```

The changes in this template are similar to how previous forms were 
handled. The final part is to add the form creation and handling in the 
view function:

```python
# app/routes.py: Post submission form in index view function
from app.forms import PostForm
from app.models import Post

@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    form = PostForm()
    if form.validate_on_submit():
        post = Post(body=form.post.data, author=current_user)
        db.session.add(post)
        db.session.commit()
        flash('Your post is now live!')
        return redirect(url_for('index'))
    posts = [
        {
            'author': {'username': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'username': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
    return render_template('index.html', 
                           title = 'Home', 
                           posts = posts, 
                           form = form)
```

Let's review the changes in this view function one by one:

* I'm now importing the `Post` and `PostForm` classes.
* I accept `POST` requests in both routes associated with the `index` 
view function in addition to `GET` requests, since this view function 
will now receive form data.
* The form processing logic inserts a new `Post` record into the 
database.
* The template receives the `form` object as an additional argument, so 
that it can render the text field.

Before I continue, I wanted to mention something important related to 
processing of web forms. Notice how after I process the form data, I end 
the request by issuing a redirect to the home page. I could have easily 
skipped the redirect and allowed the function to continue down into the 
template rendering part, since this is already the index view function.

So, why the redirect? It is a standard practice to respond to a `POST` 
request generated by a web form submission with a redirect. This helps 
mitigate an annoyance with how the refresh command is implemented in web 
browsers. All the web browser does when you hit the refresh key is to 
re-issue the last request. If a `POST` request with a form submission 
returns a regular response, then a refresh will re-submit the form. 
Because this is unexpected, the browser is going to ask the user to 
confirm the duplicate submission, but most users will not understand 
what the browser is asking them. But if a `POST` request is answered 
with a redirect, the browser is now instructed to send a `GET` request 
to grab the page indicated in the redirect, so now the last request is 
not a `POST` request anymore, and the refresh command works in a more 
predictable way.

This simple trick is called the [Post/Redirect/Get](https://en.wikipedia.org/wiki/Post/Redirect/Get) 
pattern. It avoids inserting duplicate posts when a user inadvertently 
refreshes the page after submitting a web form.

![img](08-pagination-a.png)

![img](08-pagination-b.png)

### Displaying Blog Posts

If you recall, I created a couple of fake blog posts that I've been 
displaying in the home page for a long time. These fake objects are 
created explicitly in the `index` view function as a simple Python list:

```python
    posts = [
        {
            'author': {'username': 'John'},
            'body': 'Beautiful day in Portland!'
        },
        {
            'author': {'username': 'Susan'},
            'body': 'The Avengers movie was so cool!'
        }
    ]
```

But now I have the `followed_posts()` method in the `User` model that 
returns a query for the posts that a given user wants to see. So now I 
can replace the fake posts with real posts:

```python
# app/routes.py: Display real posts in home page
@app.route('/', methods=['GET', 'POST'])
@app.route('/index', methods=['GET', 'POST'])
@login_required
def index():
    # ...
    posts = current_user.followed_posts().all()
    return render_template('index.html', 
                           title = 'Home', 
                           posts = posts, 
                           form = form)
```

The `followed_posts` method of the `User` class returns a SQLAlchemy 
query object that is configured to grab the posts the user is interested 
in from the database. Calling `all()` on this query triggers its 
execution, with the return value being a list with all the results. So I 
end up with a structure that is very much alike the one with fake posts 
that I have been using until now. It's so close that the template does 
not even need to change.

![img](08-pagination-c.png)
